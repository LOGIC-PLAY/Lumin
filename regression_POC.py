# -*- coding: utf-8 -*-
"""
Created on Sat Feb  6 14:09:38 2021

@author: mahesh
"""


#---------------------------------basic_libs------------------------
import pandas as pd
import numpy as np

#-------------------------------data_preporcessing_libs-------------
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.model_selection import train_test_split

#-----------------------regression_algorithms-----------------------
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor,GradientBoostingRegressor

#-----------------------regression_metrics--------------------------
from sklearn.metrics import max_error,mean_absolute_error,mean_squared_error,r2_score, mean_absolute_percentage_error
from tqdm import tqdm

#  MAPE only in sklearn ver. >0.24.1

#---------------------plotting_and_presentation---------------------
import plotly.graph_objects as go
import plotly.figure_factory as ff
import streamlit as st
   

#--------------------test cases-------------------

st.set_option('deprecation.showfileUploaderEncoding', False)
st.title("Project Lumin -- Regression report")
st.markdown("this is a automated report generated by Project Lumin, an Unified Machine Learning Framework.")
#-------------USER DEFINED-----------
data_path = st.file_uploader("drop a csv file here", type = ['csv'])
if data_path:
    data = pd.read_csv(data_path)
    tar_var = st.selectbox("choose Y var(prediction)",list(data.columns))
    if st.button("press here"):
        target = data[tar_var]
        
        #------------------preprocessing-------------------------
        
        drop_str = [col for col in data.columns if type(data[col][0]) == str]
        data_head = data.copy(deep = True)      #is used in presentation
        data = data.drop(drop_str,axis = 1)
        data = data.drop(target.name, axis = 1) #dropping y from data
        corr_mat = data_head.corr()             # for later use in presentation
        pca = False                             # FIX THIS!
        if len(data.columns) > 2:
            pca = True
        
        #-------------------feature scaling-------------------------------- 
        
        sc_1 = StandardScaler()
        sc_2 = StandardScaler()
        x_scaled = sc_1.fit_transform(data)
        y_scaled = sc_1.fit_transform(np.array(target).reshape(-1,1))
        
        x_train,x_test,y_train,y_test = train_test_split(x_scaled,y_scaled ,test_size = 0.2, 
                                                         random_state = 177013)
        
        #----------PCA only if >2 cols---------------
        if pca == True:
            pca = PCA(n_components = 2)
            x_train = pd.DataFrame(data = pca.fit_transform(x_train),columns = ['pc1',"pc2"]).iloc[:,:].values
            x_test = pca.transform(x_test)
            
        #------------------------------------------model_building-------------------------
        #----------------POLYNOMIAL REGRESSION is disqualified for reasons
            
        regression_models = {"LINEAR_REG":LinearRegression(),"SVR":SVR(),"DTR":DecisionTreeRegressor(),
                             "RFR":RandomForestRegressor(n_estimators = 400),
                             "XGBR": GradientBoostingRegressor(n_estimators = 400)}
        
        metric_dict = {}
        for name,algorithm in tqdm(regression_models.items()):
            model = algorithm
            model.fit(x_train,y_train.ravel())
            y_pred = model.predict(x_test)
            metric_dict[name] = {"Max_error":round(max_error(y_test, y_pred),5),
                                 "MAE":round(mean_absolute_error(y_test, y_pred),3),
                                 "MSE": round(mean_squared_error(y_test, y_pred),3),
                                 "R2-score": round(r2_score(y_test, y_pred),5),
                                 "RMSE" : round(mean_squared_error(y_test, y_pred,squared = False),3),
                                 "MAPE": round(mean_absolute_percentage_error(y_test,y_pred),3)}
            
        metric_df = pd.DataFrame(metric_dict)
        metric_df.reset_index(inplace = True)
        
        #---------------------------Presentation----------------------------------
        
        
        
        #-------------------------------------view data --------------------------
        
        st.header("Lets look at what we are dealing with ")
        st.dataframe(data_head.head())
        #-----------------------------corelation_plot----------------------------------
        st.header("Corelation Plot")
        corr_val = corr_mat
        corr = ff.create_annotated_heatmap(y = corr_val.index.tolist(),
                                           x = corr_val.columns.tolist(),
                                           z = corr_val.values)
        for i in range(len(corr.layout.annotations)):
            corr.layout.annotations[i].font.size = 8
            corr.layout.annotations[i].text = str(round(float(corr.layout.annotations[i].text),4))
        corr.update_layout(width = 800,height = 800)
        st.plotly_chart(corr)
        
        #-------------------------------metric table----------------------------
        st.header("METRICS FOR REGRESSION ALGORITHMS")
        table = ff.create_table(metric_df)
        table.update_layout(width = 1350)
        st.plotly_chart(table)
        st.markdown("MAPE does not represent the output as a percentage in range [0, 100]. Instead, it represents in range [0, 1/eps].")
        
        #------------------------------RADAR_plots------------------------------
        radar = go.Figure()
        metric_df = metric_df.drop([0],axis = 0)
        
        for metric_lis in metric_df.columns[1:].values:  
            radar.add_trace(go.Scatterpolar(r=metric_df[metric_lis].tolist(),
                                            theta=metric_df["index"].tolist(),
                                            fill='toself',
                                            name= metric_lis))   
        radar.update_layout(polar=dict(radialaxis=dict(visible=True,range=[0, 2])),
                            showlegend=True,
                            title = "Radar Plot! (use legend to disable individual algorithms)",
                            width = 800,height = 650)
        
        st.plotly_chart(radar)





















